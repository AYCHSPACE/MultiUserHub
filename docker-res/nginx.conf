# Log errors to stdout
error_log /dev/stdout warn;

# TODO get namespace by env variable

events {}
http {
    # if SERVICE_SSL_ENABLED flag is set, following lines are commented in and the path to the certs is set
    #ssl_certificate
    #ssl_certificate_key
    log_format nginx '$remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent $request_length $request_time $upstream_response_time '
                 '"$http_referer" "$http_user_agent"';
    access_log /var/log/nginx/access.log nginx;

    lua_package_path "/etc/nginx/nginx_plugins/lua-resty-http/?.lua;;";

    client_max_body_size 1G;
    client_body_timeout 300s;
    client_header_timeout 120s;

    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    map $http_referer $served_referer {
       default $http_referer;
       "~.*hub.*" $host/hub/;
    }

    server {
        listen 8092 ssl;
        
        error_page 502 504 /5xx.html;
        error_page 401 /401.html;
        # Website was accessed via http, redirect to https:
        error_page 497 https://$http_host$request_uri;
        
        # variables modified during run.py-execution

        set $service_suffix ''; # used to resolve services correctly; in Kubernetes, the full-qualified name has to be given.

        location = /5xx.html {
            root /resources/;
            internal;
        }

        location = /401.html {
            root /resources/;
            internal;
        }

        location / {
            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "$http_origin";
                add_header Access-Control-Allow-Credentials "true";
                add_header Access-Control-Allow-Methods "GET, OPTIONS, DELETE, POST, PUT";
                add_header Access-Control-Allow-Headers "Authorization, Content-Type";
                add_header Content-Length 0;
                add_header Content-Type text/plain;
                return 200;
            }


            set $ref "";
            access_by_lua_block {
                if (ngx.var.http_referer ~= nil and ngx.var.http_referer ~= "") then
                    ngx.var.ref = string.gsub(ngx.var.http_referer, "https", "http")
                end
            }

            proxy_set_header Referer $ref;
            add_header Access-Control-Allow-Origin "$http_origin" always;
            add_header Access-Control-Allow-Credentials "true" always;
            proxy_hide_header Access-Control-Allow-Origin; # hide the Access-Control-Allow-Origin header sent from the server, as it is set by nginx
            proxy_hide_header WWW-Authenticate;
            proxy_buffering off;
            proxy_set_header Host $http_host;
            proxy_pass http://localhost:8000;
        }

        location ~* /(api/kernels/[^/]+/(channels|iopub|shell|stdin)|terminals/websocket)/? {
            proxy_pass http://localhost:8000;

            proxy_set_header Referer $served_referer;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_hide_header content-security-policy;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        #location  ~* (/user/(?<user>([a-zA-Z0-9-]+)))?/tools/(?<tool>([^/]+))(?<path_res>(/.*))? {
        # user_server is for JupyterHub's named server access
        location  ~* (/user/(?<user>([a-zA-Z0-9-]+))(/(?<user_server>([a-zA-Z0-9-]+)))?)?/tools/(?<tool>([^/]+))(?<path_res>(/.*))? {
            resolver 127.0.0.11; # use Docker's DNS entries

            if ($path_res = false) {
                set $path_res "/";
            }

            # Define the user_path variable so lua can write to it
            set $user_path '';

            access_by_lua_block {
                local http = require "resty.http"
                local http_connection = http.new()

                local original_user = ngx.var.user
                local original_server_name = ngx.var.user_server
                local ping_url = "/user/" .. ngx.var.user .. "/tooling/ping"
                ngx.var.user_path = ngx.var.user
                if (ngx.var.user_server ~= nil and ngx.var.user_server ~= "") then
                    ngx.var.user_path = ngx.var.user .. "/" .. ngx.var.user_server
                    ping_url = "/user/" .. ngx.var.user_path .. "/tooling/ping"
                    ngx.var.user = ngx.var.user .. ngx.var.user_server
                end
                
                local res, error = http_connection:request_uri(
                    "http://jupyter-" .. ngx.var.user .. ngx.var.service_suffix .. ":8091" .. ping_url, 
                    {
                        method = "GET", 
                        headers = {['Cookie'] = ngx.var.http_cookie}
                    }
                )

                if error ~= nil or res == nil or res.status ~= 200 then
                    return ngx.redirect("/hub/home")
                end
            }

            proxy_set_header Host $host;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            default_type text/html; # if no Content-Type header is set, assume it is html (needed for Ungit)

            proxy_pass http://jupyter-$user:8091/user/$user_path/tools/$tool$path_res$is_args$args;
        }
    }
}

# Distribute incoming requests based on the ssl_preread_protocol header
stream {
    upstream ssh {
      server 127.0.0.1:22;
    }

    upstream web {
      server 127.0.0.1:8092;
    }

    map $ssl_preread_protocol $upstream {
         "" ssh;
         default web;
    }

    # SSH and SSL on the same port
    # in run.py the ports 8092 and 8091 of the listen directives will be switched
    server {
        listen 8091;

        proxy_pass $upstream;
        ssl_preread on;
    }
}
