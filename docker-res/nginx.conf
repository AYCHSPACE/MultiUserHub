# Log errors to stdout
error_log /dev/stdout warn;

# TODO get namespace by env variable

events {}
http {
    # if SERVICE_SSL_ENABLED flag is set, following lines are commented in and the path to the certs is set
    #ssl_certificate
    #ssl_certificate_key
    log_format nginx '$remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent $request_length $request_time $upstream_response_time '
                 '"$http_referer" "$http_user_agent"';
    access_log /var/log/nginx/access.log nginx;

    lua_package_path "/etc/nginx/nginx_plugins/lua-resty-http/?.lua;;";

    client_max_body_size 1G;
    client_body_timeout 300s;
    client_header_timeout 120s;

    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    map $http_referer $served_referer {
       default $http_referer;
       "~.*hub.*" $host/hub/;
    }

    server {
        listen 8091;#ssl
        
        error_page 502 504 /5xx.html;
        error_page 401 /401.html;
        # Website was accessed via http, redirect to https:
        error_page 497 https://$http_host$request_uri;

        #auth_basic "Restricted Access";
        #auth_basic_user_file /etc/nginx/.htpasswd;
        
        # variables modified during run.py-execution

        set $service_suffix ''; # used to resolve services correctly; in Kubernetes, the full-qualified name has to be given.

        location = /5xx.html {
            root /resources/;
            internal;
        }

        location = /401.html {
            root /resources/;
            internal;
        }

        location / {
            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "$http_origin";
                add_header Access-Control-Allow-Credentials "true";
                add_header Access-Control-Allow-Methods "GET, OPTIONS, DELETE, POST, PUT";
                add_header Access-Control-Allow-Headers "Authorization, Content-Type";
                add_header Content-Length 0;
                add_header Content-Type text/plain;
                return 200;
            }

            add_header Access-Control-Allow-Origin "$http_origin" always;
            add_header Access-Control-Allow-Credentials "true" always;
            proxy_hide_header Access-Control-Allow-Origin; # hide the Access-Control-Allow-Origin header sent from the server, as it is set by nginx
            proxy_hide_header WWW-Authenticate;
            proxy_buffering off;
            proxy_set_header Host $http_host;
            proxy_pass http://localhost:8000;
        }

        location ~* /(api/kernels/[^/]+/(channels|iopub|shell|stdin)|terminals/websocket)/? {
            proxy_pass http://localhost:8000;

            proxy_set_header Referer $served_referer;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_hide_header content-security-policy;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # if url is called without trailing slash, add a trailing slash, otherwise it cannot be routed correctly.
        # example: /tools/netdata -> /tools/netdata/ ; /tools/vnc -> /tools/vnc/ ; /tools/netdata/foo -(unchanged)> /tools/netdata/foo
        location ~* /tools/[^/]+$ {
            return 301 $scheme://$http_host$request_uri/;
        }

        #location  ~* (/user/(?<user>([a-zA-Z0-9-]+)))?/tools/(?<tool>([^/]+))(?<path_res>(/.*))? {
        # user_server is for JupyterHub's named server access
        location  ~* (/user/(?<user>([a-zA-Z0-9-]+))(/(?<user_server>([a-zA-Z0-9-]+)))?)?/tools/(?<tool>([^/]+))(?<path_res>(/.*))? {
            resolver 127.0.0.11; # use Docker's DNS entries

            if ($path_res = false) {
                set $path_res "/";
            }

            # if ($user != "") {
            #     add_header Set-Cookie "current_jupyterhub_user=${user};Path=/";
            #     ngx.var.cookie_current_jupyterhub_user = ngx.var.user
            # }

            access_by_lua_block {
                local http = require "resty.http"
                local http_connection = http.new()

                if ((ngx.var.user == nil or ngx.var.user == '') and ngx.var.cookie_current_jupyterhub_user ~= nil) then
                    ngx.var.user = ngx.var.cookie_current_jupyterhub_user --string.match(ngx.var.http_referer, "http.*/user/([^/]+)/.*")
                end

                local original_user = ngx.var.user
                local original_server_name = ngx.var.user_server
                local ping_url = "/user/" .. ngx.var.user .. "/tooling/ping"
                if (ngx.var.user_server ~= nil and ngx.var.user_server ~= "") then
                    ping_url = "/user/" .. ngx.var.user .. "/" .. ngx.var.user_server .. "/tooling/ping"
                    ngx.var.user = ngx.var.user .. ngx.var.user_server
                end

                if (ngx.var.user ~= nil and ngx.var.user ~= "") then
                    ngx.header["Set-Cookie"] = {"current_jupyterhub_user=" .. ngx.var.user .. ";Path=/"}
                    --ngx.var.cookie_current_jupyterhub_user = ngx.var.user
                end
                
                local res, error = http_connection:request_uri(
                    "http://jupyter-" .. ngx.var.user .. ngx.var.service_suffix .. ":8091" .. ping_url, 
                    {
                        method = "GET", 
                        headers = {['Cookie'] = ngx.var.http_cookie}
                    }
                )

                if error ~= nil or res == nil or res.status ~= 200 then
                    return ngx.redirect("/hub/home")
                end
            }

            proxy_set_header Host $host;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            default_type text/html; # if no Content-Type header is set, assume it is html (needed for Ungit)

            proxy_pass http://jupyter-$user:8091/user/$user/tools/$tool$path_res$is_args$args;
        }

        # # research workspace
        # location ~* ^/workspace(/id/(?<id>([a-zA-Z0-9\-]+))/)?(tools/)? {
        #     resolver 127.0.0.11; # use Docker's DNS entries

        #     # increase buffer size so that smaller requests/responses are not buffered to a temp file (should increase speed)
        #     proxy_buffers 16 16k;  
        #     proxy_buffer_size 16k;
        #     # increase buffer size of what a client can send. Otherwise, a lot of "a client request body is buffered to a temporary file" logs come up
        #     # 10M is chosen arbitrarily.
        #     client_body_buffer_size 10M;

        #     access_by_lua_block {
        #         local jwt = require("nginx-jwt")

        #         jwt.auth({
        #             ["username"]=function (val, jwt_obj) 
        #                     if (ngx.var.id == '') then
        #                         ngx.var.id = val --use the name of the JWT token to route to the correct container. No one can temper it as then the JWT token is invalid
                            
        #                         if (ngx.var.uri == '/workspace' or ngx.var.uri == '/workspace/') then
        #                             ngx.req.set_uri("/workspace/id/" .. val)
        #                         end
        #                     end

        #                     if (jwt_obj.payload["tokenType"] ~= "shortTerm") then
        #                         ngx.status = 403
        #                         ngx.say("API tokens are not allowed to access workspace")
        #                         ngx.exit(403)
        #                     end

        #                     -- val correspondes to the value of the jwt of field 'username'
        #                     return (val == ngx.var.id or jwt.table_contains(jwt_obj.payload["$int_perms"], "admin"))
        #                 end
        #         })

        #         local http = require "resty.http"
        #         local http_connection = http.new()
        #         -- check whether container does exist to directly route to it.
        #         -- if the container does not exist, call the /check endpoint from the Studio to load it
        #         local res, error = http_connection:request_uri("http://" .. ngx.var.studio_namespace .. "-workspace-" .. ngx.var.id .. ngx.var.service_suffix .. ":8091/ping", {method = "GET"})
        #         if error ~= nil or res == nil or res.status ~= 200 then
        #             local res, error  = http_connection:request_uri("http://127.0.0.1:8090/studio/admin/workspace/check?id=" .. ngx.var.id, {method = "GET"})

        #             if error ~= nil or res == nil or res.status ~= 200 then
        #                 ngx.log(ngx.ERR, "Request to check research container 'workspace-" .. ngx.var.id .. "' failed.")
        #             end
                
        #             ngx.exec("/5xx.html")
        #         end
        #         ngx.log(ngx.DEBUG, "Checked availability of research-workspace")
        #     }

        #     proxy_set_header Host $host;
        #     proxy_http_version 1.1;
        #     proxy_set_header Upgrade $http_upgrade;
        #     proxy_set_header Connection $connection_upgrade;

        #     default_type text/html; # if no Content-Type header is set, assume it is html (needed for Ungit)

        #     proxy_pass http://$studio_namespace-workspace-$id$service_suffix:8091;
        # }
    }
}
